/*
 * Scala.js (https://www.scala-js.org/)
 *
 * Copyright EPFL.
 *
 * Licensed under Apache License 2.0
 * (https://www.apache.org/licenses/LICENSE-2.0).
 *
 * See the NOTICE file distributed with this work for
 * additional information regarding copyright ownership.
 */

package org.scalajs.linker.frontend.modulesplitter

import scala.annotation.tailrec

import scala.collection.immutable
import scala.collection.mutable

import java.nio.charset.StandardCharsets
import java.nio.ByteBuffer

import org.scalajs.ir.Names.ClassName
import org.scalajs.ir.SHA1
import org.scalajs.linker.standard.ModuleSet.ModuleID

/** Tagger groups classes into coarse modules.
 *
 *  It is the primary mechanism for the FewestModulesAnalyzer but also used
 *  by the SmallModulesForAnalyzer.
 *
 *  To group classes into modules appropriately, we want to know for
 *  each class, "how" it can be reached. In practice, this means we
 *  record the path from the original public module and every
 *  dynamic import hop we made.
 *
 *  Of all these paths, we only care about the "simplest" ones. Or
 *  more formally, the minimum prefixes of all paths. For example,
 *  if a class is reachable by the following paths:
 *
 *  - a -> b
 *  - a -> b -> c
 *  - d -> c
 *  - d
 *
 *  We really only care about:
 *
 *  - a -> b
 *  - d
 *
 *  Because if we reach the class through a path that goes through
 *  `c`, it is necessarily already loaded.
 *
 *  Once we have obtained this minimal set of paths, we use the last
 *  element of each path to determine the final module
 *  grouping. This is because these have an actual static dependency
 *  on the node in question.
 *
 *  Merging these tags into a single `ModuleID` is delegated to the
 *  caller.
 *
 *  == Class Exclusion ==
 *  Classes can be excluded from the modules generated by Tagger.
 *
 *  For excluded classes, the Tagger assumes that they are in a module
 *  provided by a different part of the overall analysis.
 *
 *  The (transitive) dependencies of the class are nevertheless taken into
 *  account and tagged as appropriate. In particular, to avoid cycles and
 *  excessive splitting alike (see #4835), we need to track, for each class,
 *  the number of hops through excluded classes can reach them. The numbers
 *  of hops are included in the final tagging mechanism.
 */
private class Tagger(infos: ModuleAnalyzer.DependencyInfo,
    excludedClasses: scala.collection.Set[ClassName] = Set.empty) {
  import Tagger._

  private[this] val allPaths = mutable.Map.empty[ClassName, Paths]

  final def tagAll(internalModuleIDPrefix: String): scala.collection.Map[ClassName, ModuleID] = {
    tagEntryPoints()
    for {
      (className, paths) <- allPaths
      if !excludedClasses.contains(className)
    } yield {
      className -> paths.moduleID(internalModuleIDPrefix)
    }
  }

  private def tag(className: ClassName, pathRoot: ModuleID, pathSteps: List[ClassName],
      excludedHopCount: Int, fromExcluded: Boolean): Unit = {
    val isExcluded = excludedClasses.contains(className)

    val newExcludedHopCount =
      if (isExcluded && !fromExcluded) excludedHopCount + 1
      else excludedHopCount

    val updated = allPaths
      .getOrElseUpdate(className, new Paths)
      .put(pathRoot, pathSteps, newExcludedHopCount)

    if (updated) {
      val classInfo = infos.classDependencies(className)
      classInfo
        .staticDependencies
        .foreach(staticEdge(_, pathRoot, pathSteps, newExcludedHopCount, fromExcluded = isExcluded))

      classInfo
        .dynamicDependencies
        .foreach(dynamicEdge(_, pathRoot, pathSteps, newExcludedHopCount, fromExcluded = isExcluded))
    }
  }

  private def staticEdge(className: ClassName, pathRoot: ModuleID, pathSteps: List[ClassName],
      excludedHopCount: Int, fromExcluded: Boolean): Unit = {
    tag(className, pathRoot, pathSteps, excludedHopCount, fromExcluded)
  }

  private def dynamicEdge(className: ClassName, pathRoot: ModuleID, pathSteps: List[ClassName],
      excludedHopCount: Int, fromExcluded: Boolean): Unit = {
    tag(className, pathRoot, pathSteps :+ className, excludedHopCount, fromExcluded)
  }

  private def tagEntryPoints(): Unit = {
    for {
      (moduleID, deps) <- infos.publicModuleDependencies
      className <- deps
    } {
      staticEdge(className, pathRoot = moduleID, pathSteps = Nil,
          excludedHopCount = 0, fromExcluded = false)
    }
  }
}

private object Tagger {

  /** "Interesting" paths that can lead to a given class.
   *
   *  "Interesting" in this context means:
   *  - All direct paths from a public dependency.
   *  - All non-empty, mutually prefix-free paths of dynamic import hops.
   */
  private final class Paths {
    private val excludedHopCounts = mutable.BitSet.empty
    private val direct = mutable.Set.empty[ModuleID]
    private val dynamic = mutable.Map.empty[ModuleID, DynamicPaths]

    def put(pathRoot: ModuleID, pathSteps: List[ClassName], excludedHopCount: Int): Boolean = {
      /* We do not add `excludedHopCount == 0` to the set, although 0 is not
       * supposed to be special here. `moduleID()` has a dedicated code path
       * for when the only hop count to reach a class would be 0. By excluding
       * 0 here, that dedicated code path amounts to testing
       * `excludedHopCounts.isEmpty`. It is also worth nothing that it will
       * always be 0 in the `FewestModules` mode.
       */
      val hopCountsChanged = excludedHopCount > 0 && excludedHopCounts.add(excludedHopCount)
      val stepsChanged = if (pathSteps.isEmpty) {
        direct.add(pathRoot)
      } else {
        dynamic
          .getOrElseUpdate(pathRoot, new DynamicPaths)
          .put(pathSteps)
      }
      hopCountsChanged || stepsChanged
    }

    def moduleID(internalModuleIDPrefix: String): ModuleID = {
      if (direct.size == 1 && dynamic.isEmpty && excludedHopCounts.isEmpty) {
        /* Class is only used by a single public module. Put it there.
         *
         * Note that we must not do this if there are any dynamic modules
         * requiring this class. Otherwise, the dynamically loaded module
         * will try to import the public module (but importing public modules is
         * forbidden).
         */
        direct.head
      } else {
        /* Class is used by multiple public modules and/or dynamic edges.
         * Create a module ID grouping it with other classes that have the same
         * dependees.
         */
        val digestBuilder = new SHA1.DigestBuilder

        // Excluded hop counts
        if (!excludedHopCounts.isEmpty)
          digestBuilder.update(longsToBytes(excludedHopCounts.toBitMask))

        // Public modules using this.
        for (id <- direct.toList.sortBy(_.id))
          digestBuilder.update(id.id.getBytes(StandardCharsets.UTF_8))

        // Dynamic modules using this.
        for (className <- dynamicEnds)
          digestBuilder.updateUTF8String(className.encoded)

        // Build a hex string of the hash with the right prefix.
        @inline def hexDigit(digit: Int): Char =
          Character.forDigit(digit & 0x0f, 16)

        val id = new java.lang.StringBuilder(internalModuleIDPrefix)

        for (b <- digestBuilder.finalizeDigest()) {
          id.append(hexDigit(b >> 4))
          id.append(hexDigit(b))
        }

        ModuleID(id.toString())
      }
    }

    private def longsToBytes(longs: Array[Long]): Array[Byte] = {
      val result = new Array[Byte](longs.length * 8)
      val buf = ByteBuffer.wrap(result)
      for (long <- longs)
        buf.putLong(long)
      result
    }

    private def dynamicEnds: immutable.SortedSet[ClassName] = {
      val builder = immutable.SortedSet.newBuilder[ClassName]
      /* We ignore paths that originate in a module that imports this class
       * directly: They are irrelevant for the final ID.
       *
       * However, they are important to ensure we do not attempt to import a
       * public module (see the comment in moduleID); therefore, we only filter
       * them here.
       */
      for ((h, t) <- dynamic if !direct.contains(h))
        t.ends(builder)
      builder.result()
    }
  }

  /** Set of shortest, mutually prefix-free paths of dynamic import hops */
  private final class DynamicPaths {
    private val content = mutable.Map.empty[ClassName, DynamicPaths]

    @tailrec
    def put(path: List[ClassName]): Boolean = {
      val h :: t = path

      if (content.get(h).exists(_.content.isEmpty)) {
        // shorter or equal path already exists.
        false
      } else if (t.isEmpty) {
        // the path we put stops here, prune longer paths (if any).
        content.put(h, new DynamicPaths)
        true
      } else {
        // there are other paths, recurse.
        content
          .getOrElseUpdate(h, new DynamicPaths)
          .put(t)
      }
    }

    /** Populates `builder` with the ends of all paths. */
    def ends(builder: mutable.Builder[ClassName, Set[ClassName]]): Unit = {
      for ((h, t) <- content) {
        if (t.content.isEmpty)
          builder += h
        else
          t.ends(builder)
      }
    }
  }
}
